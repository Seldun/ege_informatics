# код без "неудачного первого хода Пети"
# TODO: код для неудачного заменить all на any и дерево уровень пети на or
# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней.
# Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в кучу один или
# четыре камня либо увеличить количество камней в куче в пять раз. Например, имея кучу из 15 камней,
# за один ход можно получить кучу из 16, 19 или 75 камней. У каждого игрока, чтобы делать ходы,
# есть неограниченное количество камней. Игра завершается в тот момент, когда количество камней в
# куче становится не менее 68.
# Победителем считается игрок, сделавший последний ход, т.д. первым получивший кучу,
# в которой будет 68 или больше камней. В начальный момент в куче было S камней; 1 ≤ S ≤ 67.
# Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
# Описать стратегию игрока — значит, описать, какой ход он должен сделать в любой ситуации,
# которая ему может встретиться при различной игре противника. В описание выигрышной стратегии не следует
# включать ходы играющего по этой стратегии игрока, не являющиеся для него безусловно выигрышными,
# т.д. не являющиеся выигрышными независимо от игры противника.
# Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Укажите минимальное
# значение S, когда такая ситуация возможна.
############################
# Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
#
# -Петя не может выиграть за один ход;
#
# —Петя может=должен выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
############################
# Найдите минимальное значение S, при котором одновременно выполняются два условия:
#
# —у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
#
# —у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

# с - номер хода в игре
# m - это количество ходов, за которое мы хотим выиграть

# def f(start, end):
#     if start == end:
#         return 1 # возвращаем 1, так как нашли путь
#     if start > end: #or start == 12:
#         return 0 # возвращаем 0, так как НЕ нашли путь
#     if start < end:
#         return f(start + 1, end) + f(start * 4, end)
'''
первый ход в игре соответствует первому ходу пети
второй ход в игре соответствует первому ходу Вани
и тд всегда

нечёт - Петя
чёт - Ваня
укажите такое значение при котором Ваня выйграл после ЛЮБОГО хода Пети (своим первым ходом)
'''
def f(s, с, m): # s - количество камней в куче | c - номер хода в игре | m (разное для 19,20,21) - количество ходов за которое мы хотим закончить игру (общие ходы (всех и пети и вани) ГАРАНТИРОВАНЫЙ выйгрыш (берём макс возможное)f(s1, s2, с, m) - для 2 куч (или доп параметры)
    if s >= 68: #s1 + s2 >= 68
        return с % 2 == m % 2 # если победа происходит в ход нужного нам игрока, то возвращается True, иначе False
    elif с == m:
        return False


    h = [f(s + 1, с + 1, m), f(s + 4, с + 1, m), f(s * 5, с + 1, m)] # список ходов
    # return any(h) if (с + 1) % 2 == m % 2 else any(h)
    return any(h) if (с + 1) % 2 == m % 2 else all(h)
    # if (с + 1) % 2 == m % 2: # если следующий ход - ход нужного нам игрока, то проходим
    #     return f(s + 1, с + 1, m) or f(s + 4, с + 1, m) or f(s * 5, с + 1, m)  # any(h)
    # else:
    #     return f(s + 1, с + 1, m) and f(s + 4, с + 1, m) and f(s * 5, с + 1, m) # all(h) после каждого уровня Пети Ваня смог хотя бы 1 раз выйграть
#
# for s in range(1, 68): #s2
#     for m in range(1, 5):
#         if f(s, 0, m): #f(7, s2, 0, m)
#             if m == 2:
#                 print(s, m) #print(7, s2, m)
#             break

# TODO: дорисуй деревья

print([s for s in range(1, 68) if f(s, 0, 2)]) #19 нужный ответ 3 тут используем any так как "неудачного первого хода Пети"
print([s for s in range(1, 68) if not f(s, 0, 1) and f(s, 0, 3)]) #20 тут мы должны вернуть all
print([s for s in range(1, 68) if not f(s, 0, 2) and f(s, 0, 4)]) #21
# not f(s, 0, 2) говорим, что ничего страшного, если вернётся false
# for s in range(1, 68):
#     if not f(s, 0, 1) and f(s, 0, 3):
#         print(s)

# 13 минимальное значение, при котором Ваня гарантированно выигрывает своим первым ходом!!!

#код для 2х куч

# def f(s1, s2, с, m):
#     if s1 + s2 >= 77:
#         return с % 2 == m % 2
#     elif с == m:
#         return False
#
#     # h = [f(s1 + 1, s2, с + 1, m), f(s1, s2 + 1, с + 1, m), f(s1 * 2, s2, с + 1, m), f(s1, s2 * 2, с + 1, m)]
#     # return any(h) if (с + 1) % 2 == m % 2 else all(h)
#     if (с + 1) % 2 == m % 2:
#         return f(s1 + 1, s2, с + 1, m) or f(s1, s2 + 1, с + 1, m) or f(s1 * 2, s2, с + 1, m) or f(s1, s2 * 2, с + 1, m)
#     else:
#         return f(s1 + 1, s2, с + 1, m) and f(s1, s2 + 1, с + 1, m) and f(s1 * 2, s2, с + 1, m) and f(s1, s2 * 2, с + 1, m)
#
#
#
# for s2 in range(1, 70):
#     for m in range(1, 5):
#         if f(7, s2, 0, m):
#             if m == 3:
#                 print(s2, m)
#             break
# def f(s, с, m): #f(s1, s2, с, m)
#     if s >= 108: #s1 + s2 >= 68
#         return с % 2 == m % 2
#     elif с == m:
#         return False

    # h = [f(s + 1, с + 1, m), f(s + 4, с + 1, m), f(s * 5, с + 1, m)]
    # return any(h) if (с + 1) % 2 == m % 2 else all(h)
#     if (с + 1) % 2 == m % 2:
#         if s % 2 == 0:
#             return f(s + 1, с + 1, m) or f(s * 1.5, с + 1, m)
#         else:
#             return f(s + 1, с + 1, m) or f(s * 2, с + 1, m)
#     else:
#         if s % 2 == 0:
#             return f(s + 1, с + 1, m) and f(s * 1.5, с + 1, m)
#         else:
#             return f(s + 1, с + 1, m) and f(s * 2, с + 1, m)
#
# for s in range(1, 108): #s2
#     for m in range(1, 5):
#         if f(s, 0, m): #f(7, s2, 0, m)
#             if m == 4:
#                 print(s, m) #print(7, s2, m)
#             break
